# client_example.py
import base64
import requests

from crypto_pqc import generate_pqc_keypair, pqc_encapsulate, pqc_decapsulate, pqc_encrypt, pqc_decrypt
from client_key_manager import load_or_create_user_keys
import oqs

SERVER = "http://127.0.0.1:8000"


def b64e(b: bytes) -> str:
    return base64.b64encode(b).decode()


def b64d(s: str) -> bytes:
    return base64.b64decode(s.encode())

def decrypt_and_print(shared_secret, nonce, ciphertext, tag):
    plaintext = pqc_decrypt(shared_secret, nonce, ciphertext, tag)
    try:
        print("Decrypted plaintext:", plaintext.decode())
    except UnicodeDecodeError:
        # if it's not UTF-8 text, just show raw bytes
        print("Decrypted plaintext (bytes):", plaintext)


def register_and_login(username: str, password: str):
    kp = load_or_create_user_keys(username)

    # Register (send public key only)
    register = requests.post(f"{SERVER}/register", json={
        "username": username,
        "password": password,
        "pqc_public_key_b64": b64e(kp["public_key"]),
    })
    print("Register response:", register.status_code, register.text)

    # Login
    resp = requests.post(f"{SERVER}/login", json={
        "username": username,
        "password": password,
    })
    resp.raise_for_status()
    token = resp.json()["access_token"]
    return kp, token


def get_peer_public_key(username: str):
    resp = requests.get(f"{SERVER}/pqc_public_key/{username}")
    resp.raise_for_status()
    return b64d(resp.json()["public_key_pqc"])


def send_pqc_message(sender_token: str, recipient: str, shared_secret: bytes, plaintext: bytes):
    nonce, ciphertext, tag = pqc_encrypt(shared_secret, plaintext)
    # here we already have kem_ciphertext from encapsulation

    headers = {"Authorization": f"Bearer {sender_token}"}
    return nonce, ciphertext, tag, headers


def fetch_and_decrypt_messages(
    username: str,
    keypair,
    token: str,
    shared_secret: str,
    box: str = "inbox",  # "inbox" or "sent",
):
    """
    Fetch /inbox or /sent for a given user and try to decrypt what they can see.

    - username: the string username ("alice", "bob", ...)
    - keypair:  the PQCKeyPair for that user (with .public_key and .secret_key)
    - token:    that user's auth token (PQC-signed)
    - box:      "inbox" or "sent"
    """
    assert box in ("inbox", "sent")
    url = f"{SERVER}/{box}"
    headers = {"Authorization": f"Bearer {token}"}

    resp = requests.get(url, headers=headers)
    resp.raise_for_status()
    messages = resp.json()

    print(f"\n=== {username}'s {box} (attempted decryption) ===")

    if not messages:
        print("  (empty)")
        return

    for m in messages:
        sender = m["sender"]
        recipient = m["recipient"]

        kem_ct = base64.b64decode(m["kem_ciphertext_b64"])
        nonce = base64.b64decode(m["nonce_b64"])
        ct = base64.b64decode(m["ciphertext_b64"])
        tag = base64.b64decode(m["tag_b64"])

        # Only the RECIPIENT can decrypt with their Kyber secret key.
        if recipient != username:
            print(f"- {sender} -> {recipient}: (cannot decrypt, {username} is not recipient)")
            continue

        # Symmetric decrypt
        try:
            plaintext = pqc_decrypt(shared_secret, nonce, ct, tag)
            print(f"- {sender} -> {recipient}: {plaintext.decode(errors='replace')}")
        except Exception as e:
            print(f"- {sender} -> {recipient}: [decryption failed: {e}]")



if __name__ == "__main__":
    # Alice and Bob example
    alice_kp, alice_token = register_and_login("alice", "alicepw")
    bob_kp, bob_token = register_and_login("bob", "bobpw")

    #Enabled SIGS

    # Alice fetches Bob's Kyber public key
    bob_pub = get_peer_public_key("bob")
    alice_pub = get_peer_public_key("alice")

    # Alice encapsulates to Bob -> PQC shared_secret + kem_ciphertext
    shared_secret, kem_ct = pqc_encapsulate(bob_pub)

    #shared_secret_a, kem_ct_a = pqc_encapsulate(alice_pub)

    msg_a = b"Hello alice, I too am a hater of 3"

    msg = b"Hello Bob, Im not a big fan of 3"

    nonce_a, ciphertext_a, tag_a = pqc_encrypt(shared_secret, msg_a)

    nonce, ciphertext, tag = pqc_encrypt(shared_secret, msg)

    headers = {"Authorization": f"Bearer {alice_token}"}
    r = requests.post(f"{SERVER}/send_message", json={
        "recipient": "bob",
        "kem_ciphertext_b64": b64e(kem_ct),
        "nonce_b64": b64e(nonce),
        "ciphertext_b64": b64e(ciphertext),
        "tag_b64": b64e(tag),
        "aad_b64": None,
    }, headers=headers)
    r.raise_for_status()
    print("Message sent:", r.json())
    decrypt_and_print(shared_secret, nonce, ciphertext, tag)



    headers = {"Authorization": f"Bearer {bob_token}"}
    r = requests.post(f"{SERVER}/send_message", json={
        "recipient": "alice",
        "kem_ciphertext_b64": b64e(kem_ct),
        "nonce_b64": b64e(nonce_a),
        "ciphertext_b64": b64e(ciphertext_a),
        "tag_b64": b64e(tag_a),
        "aad_b64": None,
    }, headers=headers)
    r.raise_for_status()
    print("Message sent:", r.json())
    decrypt_and_print(shared_secret, nonce_a, ciphertext_a, tag_a)

    fetch_and_decrypt_messages("alice", alice_kp, alice_token, shared_secret, box="inbox")
    fetch_and_decrypt_messages("alice", alice_kp, alice_token, shared_secret, box="sent")

    fetch_and_decrypt_messages("bob", bob_kp, bob_token, shared_secret, box="inbox")
    fetch_and_decrypt_messages("bob", bob_kp, bob_token, shared_secret, box="sent")
